black file_name.py

.pre-commit paskatÄ«ties

--------------------

import embag
import sensor_msgs.point_cloud2 as pc2
import numpy as np

bag = embag.Bag('path/to/bag/file.bag')

for topic, msg, t in bag.read_messages(topics=['/topic/containing/pointcloud']):
    # Convert the point cloud message to a numpy array
    pointcloud = np.array(list(pc2.read_points(msg)))

-----------------

import embag

bag = embag.Bag('/path/to/bag/file.bag')
topics = bag.topics()
print(topics)

-----------------

import rosbag
from sensor_msgs.msg import Imu

bag = rosbag.Bag('filename.bag')

linear_accel = []
orientation = []

for topic, msg, t in bag.read_messages():
    if topic == '/imu':
        imu_msg = Imu()
        imu_msg.deserialize(msg.data)
        linear_accel.append(imu_msg.linear_acceleration)
        orientation.append(imu_msg.orientation)

bag.close()

import open3d as o3d
import numpy as np

point_cloud = o3d.geometry.PointCloud()
point_cloud.points = o3d.utility.Vector3dVector(np.array(linear_accel))
o3d.visualization.draw_geometries([point_cloud])

----------------

import pcl
import numpy as np

# Assuming you have collected LiDAR data in a numpy array: lidar_data
# lidar_data should be a Nx4 numpy array containing (x, y, z, intensity) values

# Create a PCL point cloud object
point_cloud = pcl.PointCloud()

# Populate the point cloud data
lidar_data = np.array([
    [1.0, 2.0, 3.0, 150.0],
    [4.0, 5.0, 6.0, 200.0],
    # Add more points here
])

# Convert the numpy array to a PCL data structure
point_cloud.from_array(lidar_data.astype(np.float32))

# Save the point cloud to a PCD file (optional)
pcl.save(point_cloud, 'output_point_cloud.pcd')

# Perform further processing or visualization using PCL functions or tools

--------------

import numpy as np

# Fake LiDAR measurements (distance, azimuth, elevation, intensity)
lidar_data = [
    [3.0, np.radians(30), np.radians(10), 150],
    [4.5, np.radians(45), np.radians(-5), 200],
    [2.7, np.radians(60), np.radians(20), 100],
    [3.8, np.radians(90), np.radians(0), 180],
    [2.2, np.radians(120), np.radians(15), 120]
]

# Sensor position and orientation in the world frame (x, y, z, roll, pitch, yaw)
sensor_pose = [0.0, 0.0, 1.0, 0.0, 0.0, np.radians(90)]

# Transformations
translation = np.array(sensor_pose[:3])
rotation_matrix = np.array([
    [np.cos(sensor_pose[5]), -np.sin(sensor_pose[5]), 0],
    [np.sin(sensor_pose[5]), np.cos(sensor_pose[5]), 0],
    [0, 0, 1]
])

# Convert LiDAR measurements to points in the world frame
point_cloud = []
for measurement in lidar_data:
    distance, azimuth, elevation, intensity = measurement

    # Convert polar coordinates to Cartesian coordinates
    x = distance * np.cos(elevation) * np.cos(azimuth)
    y = distance * np.cos(elevation) * np.sin(azimuth)
    z = distance * np.sin(elevation)

    # Apply sensor pose transformation
    point = np.dot(rotation_matrix, [x, y, z]) + translation
    point_cloud.append(point)

# Print the resulting point cloud
for i, point in enumerate(point_cloud):
    print(f"Point {i+1}: {point}")

---------------

https://github.com/jmscslgroup/bagpy/blob/master/notebook/Bagpy%20tutorial.ipynb


----------
pyhthon project. input data raw bag file with lidar data like linear acceleration, orientation, timestampes etc. create functions which can take bag file and with math create point cloud point positions from this data

import rosbag
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def read_lidar_data(bag_file):
    lidar_data = []
    with rosbag.Bag(bag_file, 'r') as bag:
        for topic, msg, t in bag.read_messages(topics=['/imu_topic']):
            # Assuming the message contains linear acceleration and orientation data
            linear_acceleration = msg.linear_acceleration
            orientation = msg.orientation
            timestamp = msg.header.stamp.to_sec()
            lidar_data.append((timestamp, linear_acceleration, orientation))
    return lidar_data

def generate_point_cloud(lidar_data):
    point_cloud = []
    for timestamp, linear_acceleration, orientation in lidar_data:
        # Apply your mathematical transformations here to convert data to point cloud
        position = np.array([linear_acceleration.x, linear_acceleration.y, linear_acceleration.z])
        point_cloud.append((timestamp, position))
    return point_cloud

def visualize_point_cloud(point_cloud):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    for timestamp, position in point_cloud:
        ax.scatter(position[0], position[1], position[2], c='b', marker='.')
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    plt.show()

def main():
    bag_file = 'path/to/your/bag/file.bag'
    lidar_data = read_lidar_data(bag_file)
    point_cloud = generate_point_cloud(lidar_data)
    visualize_point_cloud(point_cloud)

if __name__ == "__main__":
    main()
